# 第六章 隐式图深度优先搜索

在非二叉树上的深度优先搜索（Depth-first Search）中，90%的问题，不是求组合（Combination）就是求排列（Permutation）。特别是组合类的深度优先搜索的问题特别的多。而排列组合类的搜索问题，本质上是一个“隐式图”的搜索问题。

什么是隐式图？

一个问题如果没有明确的告诉你什么是点，什么是边，但是又需要你进行搜索的话，那就是一个隐式图搜索问题了。
所以隐式图搜索的问题，首先要分析清楚什么是点什么是边。这部分内容我们将在课上进行讲解。

本章节的先修内容有：

* 通过全子集问题 Subsets 了解组合类搜索的两种形式
* 通过全子集问题 II 了解如何在搜索中去重
* 通过全排列问题 Permutations 学习排列式搜索

课后补充内容有：

* 使用非递归的方法实现全子集问题
* 下一个排列
* 第几个排列

<br></br>
## 全子集问题

为了开始学习组合类的深度优先搜索，让我们先来做一个入门练习题：全子集问题。

LintCode 练习地址：
http://www.lintcode.com/problem/subsets/

题目的意思就是求出一个集合的所有子集。假设这个集合中是没有重复元素的。你可能已经会做这个问题，但是你知道么，这个问题存在 4 种解法么？

我们将从下面的 3 个方面来讲解这个问题：

如何用最简单的递归方式来实现？
如何用可以推广到排列类搜索问题的递归方式来实现？
如果集合中有重复元素如何处理？

完整的 4 种解法的参考代码
http://www.jiuzhang.com/solution/subsets
非递归的实现方法，见课后补充内容。

---
### 最简单的递归方式
https://1256418761.vod2.myqcloud.com/c8e8a510vodtransgzp1256418761/c9dbb3027447398156689259538/v.f30.mp4

---
### 可以拓展到排列类搜索的递归方式
https://1256418761.vod2.myqcloud.com/c8e8a510vodtransgzp1256418761/ce980fda7447398156689469221/v.f30.mp4

---
### 全子集 Follow up I: 如何去重
https://1256418761.vod2.myqcloud.com/c8e8a510vodtransgzp1256418761/0ada309f7447398156690685936/v.f30.mp4

<br></br>
## 全排列问题

全排列问题是“排列式”深度优先搜索问题的鼻祖。很多搜索的问题都可以用类似全排列的代码来完成。包括我们前面学过的全子集问题的一种做法。

这一小节中我们需要掌握：

1. 普通的全排列问题怎么做
2. 有重复的全排列问题怎么做？如何在搜索类问题中去重？
3. 如何实现一个非递归的全排列算法？

---
### 普通的全排列问题
https://1256418761.vod2.myqcloud.com/c8e8a510vodtransgzp1256418761/85ff4c047447398156688628784/v.f30.mp4

---
### 有重复数的全排列问题
https://1256418761.vod2.myqcloud.com/c8e8a510vodtransgzp1256418761/81cf47a07447398156688490891/v.f30.mp4

---
### 如何实现非递归版本的全排列问题？

基本思路
非递归的全排列，采用的是迭代方式，在[如何求下一个排列](http://www.jiuzhang.com/tutorial/algorithm/439)中，我们讲过如何求下一个排列，那么我们只需要不断调用这个nextPermutation方法即可。

一些可以做得更细致的地方：

* 为了确定何时结束，建议在迭代前，先对输入nums数组进行升序排序，迭代到降序时，就都找完了。有心的同学可能还记得在nextPermutation当中，当且仅当数组完全降序，那么从右往左遍历的指针i最终会指向0。所以可以为nextPermutation带上布尔返回值，当i为0时，返回false，表示找完了。要注意，排序操作在这样一个NP问题中，消耗的时间几乎可以忽略。
* 当数组长度为1时，nextPermutation会直接返回false；当数组长度为0时，nextPermutation中i会成为-1，所以返回false的条件可以再加上i为-1。

<br></br>
## 什么是 Deep Copy？

```python
results.append(list(S))
```
这新建了一个list，list的构造接受一个Iterable对象作为参数，并将该对象内的元素按顺序添加到新建的list中。这是一次Deep Copy。

<br></br>
## 课后补充内容

---
### 全子集 Follow up II: 如何非递归？

用非递归（Non-recursion / Iteration）的方式实现全子集问题，有两种方式：

1. 进制转换（binary）
2. 宽度优先搜索（Breadth-first Search）

进制转换的方法

九章微课堂 - 《位运算入门》 中有此方法的详细讲解：
http://www.jiuzhang.com/tutorial/bit-manipulation/83

基于 BFS 的方法

在 BFS 那节课的讲解中，我们很少提到用 BFS 来解决找所有的方案的问题。事实上 BFS 也是可以用来做这件事情的。

---
### 如何求一个排列是第几个排列？

题目描述

给出一个不含重复数字的排列，求这些数字的所有排列按字典序排序后该排列的编号，编号从1开始。
例如排列[1,2,4]是第1个排列。

http://www.lintcode.com/zh-cn/problem/permutation-index/

算法描述

只需计算有多少个排列在当前排列A的前面即可。如何算呢?举个例子，[3,7,4,9,1]，在它前面的必然是某位置i对应元素比原数组小，而i左侧和原数组一样。也即[3,7,4,1,X]，[3,7,1,X,X]，[3,1或4,X,X,X]，[1,X,X,X,X]。
而第i个元素，比原数组小的情况有多少种，其实就是A[i]右侧有多少元素比A[i]小，乘上A[i]右侧元素全排列数，即A[i]右侧元素数量的阶乘。i从右往左看，比当前A[i]小的右侧元素数量分别为1,1,2,1，所以最终字典序在当前A之前的数量为1×1!+1×2!+2×3!+1×4!=39，故当前A的字典序为40。

具体步骤：

1. 用permutation表示当前阶乘，初始化为1,result表示最终结果，初始化为0。由于最终结果可能巨大，所以用long类型。
2. i从右往左遍历A，循环中计算A[i]右侧有多少元素比A[i]小，计为smaller，result += smaller * permutation。之后permutation *= A.length - i，为下次循环i左移一位后的排列数。
3. 已算出多少字典序在A之前，返回result+1。

Q：为了找寻每个元素右侧有多少元素比自己小，用了O(n^2)的时间，能不能更快些？

A：可以做到O(nlogn)！但是很复杂，这是另外一个问题了，可以使用BST，归并排序或者线段树，详见
http://www.lintcode.com/zh-cn/problem/count-of-smaller-number-before-itself/

Q：元素有重复怎么办？

A：好问题！元素有重复，情况会复杂的多。因为这会影响A[i]右侧元素的排列数，此时的排列数计算方法为总元素数的阶乘，除以各元素值个数的阶乘，例如[1,1,1,2,2,3]，排列数为6!\div(3!\times2!\times1!)6!÷(3!×2!×1!)。

为了正确计算阶乘数，需要用哈系表记录A[i]及右侧的元素值个数，并考虑到A[i]与右侧比其小的元素A[k]交换后，要把A[k]的计数减一。用该哈系表计算正确的阶乘数。

而且要注意，右侧比A[i]小的重复元素值只能计算一次，不要重复计算！

---
### 如何求下一个排列

问题描述

给定一个若干整数的排列，给出按整数大小进行字典序从小到大排序后的下一个排列。若没有下一个排列，则输出字典序最小的序列。

例如1,2,3 → 1,3,2，3,2,1 → 1,2,3，1,1,5 → 1,5,1

原题链接：

http://www.lintcode.com/problem/next-permutation-ii/

http://www.lintcode.com/problem/next-permutation/

（两题类似，一个要求原地修改，一个要求返回新的排列）

算法描述

如果上来想不出方法，可以试着找找规律，我们关注的重点应是原数组末尾。

从末尾往左走，如果一直递增，例如...9,7,5，那么下一个排列一定会牵扯到左边更多的数，直到一个非递增数为止，例如...6,9,7,5。对于原数组的变化就只到6这里，和左侧其他数再无关系。6这个位置会变成6右侧所有数中比6大的最小的数，而6会进入最后3个数中，且后3个数必是升序数组。

所以算法步骤如下：

* 从右往左遍历数组nums，直到找到一个位置i，满足nums[i] > nums[i - 1]或者i为0。
* i不为0时，用j再次从右到左遍历nums，寻找第一个nums[j] > nums[i - 1]。而后交换nums[j]和nums[i - 1]。注意，满足要求的j一定存在！且交换后nums[i]及右侧数组仍为降序数组。
* 将nums[i]及右侧的数组翻转，使其升序。

Q：i为0怎么办？

A：i为0说明整个数组是降序的，直接翻转整个数组即可。

Q：有重复元素怎么办？

A：在遍历时只要严格满足nums[i] > nums[i - 1]和nums[j] > nums[i - 1]就不会有问题。

Q：元素过少是否要单独考虑？

A：当元素个数小于等于1个时，可以直接返回。

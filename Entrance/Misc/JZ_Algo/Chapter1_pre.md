# 第一章 如何在一个月内攻破算法面试

这一节课的先修内容有：

* Coding Style
* 为什么我们不需要学习贪心法？
* 函数式编程
* 字符串类面试题的基础知识

补充内容有:

* 最长回文子串经典算法 Manacher's Algorithm（不看没事儿）
* KMP算法的替代品：Rabin Karp（看了会更深入了解哈希函数）

<br></br>
## Coding Style

前言

好的代码风格十分重要，因为这体现了你写了多少年的程序。有经验的面试官不看你的代码逻辑，一眼就能从代码风格中看出你的水平来。

几个技巧快速提高代码风格

* 二元运算符左右两边加空格
* if, for 和括号之间加空格
* 严格按照要求进行程序缩进
* 即使 if / for 语句内部只有一句话，也要加上花括号
* 变量名使用有意义的英文名，不要用a,b,c,s1,s2
* 区分不同的逻辑块，逻辑块之间用空行隔开，简要注释每个部分做的事情
* 多用 Helper Function 或子函数，不要所有程序都写在一个大函数里

其他参考资料

C++ 、Python 的同学请阅读
http://zh-google-styleguide.readthedocs.io/en/latest/

Java 的同学请阅读
https://google.github.io/styleguide/javaguide.html


<br></br>
## 为什么不需要学习贪心算法？

许多同学问我，为什么课程中没有包含贪心算法(Greedy)，是否可以将贪心算法列入教学计划中。每一次我总是苦口婆心的规劝他们：不要把时间浪费在贪心法上，学了根本没有用。

为什么学习贪心法没有用？这是一个值得讨论的问题。从我看来，有如下的三个方面的原因：

* 你想得到的贪心法，都是错的。
* 面试基本不会考
* 没有通用性

---
### 1. 你想得到的贪心法，都是错的

首先我们需要知道，什么是贪心法。贪心法就好比挑老公时，只看他当前是不是腰缠万贯，不看他未来是否飞黄腾达。而其他的一些算法如动态规划，就好比你通过仔细的调查，发现虽然他现在是一个穷小子，但是是因为身为富二代的他不愿意接受父亲安排，自己出来独自闯荡，但是未来终究要继承千亿家业。

因此，贪心法可以说，是一种目光短浅的算法。一般在算法问题中，可以使用贪心算法的问题，其贪心策略往往都比较复杂，一般人是想不到的。而你容易想到的那些贪心策略，往往都是错的。

举一个实际的例子：

>求图中A点到B点的最短路径（点与点之间的距离是正整数）。

错误的贪心策略：

>从A出发，选择里A最近的点X，走到X，然后选择离X最近的点Y，走到Y...

正确的贪心策略（Dijkstra算法）：

>使用hashmap distance = {} 记录所有点到起点A的最短距离。一开始 distance = {A: 0}，代表目前只有A离起点的最短距离我们是确定知道的。然后在Distance中的点和非distance中的点中找到最小的一对X,Y, 使得 distance[X] + (X到Y的直接连接距离) 最小。其中X在distance里（已经被确认找到了最短距离），Y不在distance里（还没有被确认找到了最短距离）。然后将Y加入distance，并把距离设为 distance[X] + (X到Y的直接连接距离）。

怎么样，正确的贪心算法是不是非常复杂？

---
### 2. 面试基本不会考

贪心法的问题，面试基本不会考，因为等同于考智力题或者是背诵题。一个面试官想要自己凭空创造出一个面试题是使用贪心算法的，是非常困难的。（参见LintCode上的贪心算法的题目所占比例可知）。既然如此，如果面试中被问到了贪心算法，那么一定是一道经典的贪心问题，这类问题，我们可以称之为背诵题。因为大多数同学（除了智商很高，或者有算法竞赛经历的那一批），是不可能在面试的时候想得出解法的。

举几个例子：加油站问题 Gas Station，这个题的做法是，从任意站点出发，走一圈，找到这一圈里剩余Gas最少的那一站，然后从这一站出发走一圈，如果在这一站出发可以顺利走完全程，那么就可以行，否则就不可行。像这样的算法，是需要进行数学证明来证明其正确性的，面试官是没有能力出这样的面试题的。

从另外一个角度来说，贪心算法的题，对于程序的实现能力要求并不高，也违背了公司通过算法题面试主要是希望考察大家的程序实现能力这一点。所以面试官和公司也都不倾向于将贪心算法作为面试的算法问题。

---
### 3. 没有通用性

二分法，动态规划算法，分治算法，搜索算法等等，很多的算法都是具有通用性的。也就是说，在题目A里，你用了这个算法，在其他的题目B里，你可能完全可以用一样的算法和思路去解决。

而贪心法，他不是“一个算法”，而是“一类算法”的统称，他更多的是一种高屋建瓴的算法思想，而不是具体实施的算法步骤。所以基本的情况就是，你在题目A里用了某个贪心算法解决了这个问题，然后这个题中用到的贪心法，永远也找不到第二个题用类似的方法来解决。

每个题是完全独立的且没有任何联系，这对于学习者来说，无非是背诵越多知道的越多。无法触类旁通，无法举一反三。因此将时间浪费在贪心法上的话，只能是吃力不讨好。

---
### __需要“背诵”的贪心算法的题__

当然，面试中也不是说完全不可能碰到贪心算法，只是几率非常的小，你只需要“背诵”如下的一些几个题的贪心解法就好了：

http://www.jiuzhang.com/qa/2099/


<br></br>
## 函数式编程

在一个好的编程风格中，将部分独立的逻辑函数化是一个重要的手段。

<br></br>
## 字符串类面试题的基础知识

Python 的字符串是一个类。

---
### 如何判断两个字符串是否相等

Python中判断字符串相等的方式

Python可以直接使用==判断字符串是否相等:

---
### 字符串遍历

```python
s = "Hello"
for i in range(len(s)):
    s[i].....
#另一种写法
for c in s:
    c......
```

使用上述方式来遍历python中的字符串。
其中len(s) 获取字符串的长度, 使用s[i]可以访问对应位置的字符。
Python中的字符串是不可变的，字符串一但生成就不能被改变，因此不能直接用s[i]=x的方式改变字符串。例如我们使用‘+’进行字符串连接，会产生新的字符串，原串不会发生任何变化；使用replace() 进行替换某些字符的时候也是产生新的字符串，不会更改原有字符串。

---
### 其他常用的一些字符串操作

其他还有很多常见的一些 String 的函数经常用到，如:

* substring, 取子字符串
* startsWith, 判断一个字符串是否以某个字符串开头
* endsWith, 判断一个字符串是否以某个字符串结尾
* compareTo, 比较两个字符串的大小，一般用于按照字典序排序字符串
* indexOf，查询一个字符串里另外一个字符串第一次出现的位置
* lastIndexOf, 查询一个字符串里另外一个字符串出现的最后一个位置
* format, 格式化字符串
* 请前往参考资料获得更详细的用法描述

参考资料
Python: http://www.runoob.com/python/python-strings.html

<br></br>
## 与面试官的沟通技巧

---
### 沟通的基本原则

与面试官沟通的基本原则是：

>不要把面试官当作你的 Interviewer，而要当作你的 Co-worker

所以你们俩之间：

1. 你可以问他索要提示，但是尽可能的不要问太多提示。正如工作中，你可以问你的同事寻求帮助，但是你问太多，问得事无巨细人家也很烦。
2. 沟通之后再动手。正如工作中，你的同事和你合作的时候，不会喜欢你一声不吭的先按照自己的想法把代码写了。
3. 意见不合别吵架，先认可对方的想法。正如工作中，你和同事讨论一个问题的不同解决方案的时候，最好先说，我觉得你的方法挺好的，然后再说，不过我觉得有个问题。而不是：我艹你这什么sb方案 / 这肯定不对呀 / blabla。何况面试过程中，面试官是开外挂作弊知道了正确答案的一方，多认可他提出的质疑。

---
### 写代码的时候如何沟通？

面试中有两类极端的求职者：

第一类：一边写一边说，生怕面试官 for 循环看不懂。

第二类：一声不吭开始写。

这两类求职者都容易挂掉面试。第一类求职者 80%+ 会不够时间写完面试题。第二类求职者 60%+ 会理解错面试官想要他实现的内容或者使用了错误的方法进行实现。

更好的办法是：

1. 首先和面试官进行算法和实现方式上的沟通，从面试官那里得到确认你的方法是OK的，写出来是可以过的。
2. 开始写代码时，只对一些可能对方不太看得懂的做解释。如果他正在玩手机没看你，就不用理他赶紧写完。
3. 写完之后再一股脑给他解释代码

这样就算你没有足够的时间解释代码，但是代码只要能写完，挂的几率就减少了很多。


<br></br>
## 第一章课后补充内容

本章的补充内容有：

* 使用 Rabin Karp 算法解决 strstr（必学）
* 最长回文子串O(N)算法 —— Manacher's Algorithm（选学）


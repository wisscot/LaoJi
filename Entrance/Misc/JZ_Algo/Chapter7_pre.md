# 哈希表与堆

<br></br>
## 栈 Stack

我们在前面的二叉树的学习中，已经学习了如何使用 Stack 来进行非递归的二叉树遍历。

这里我们来看看栈在面试中的其他一些考点和考题：

1. 如果自己实现一个栈？
2. 如何用两个队列实现一个栈？
3. 用一个数组如何实现三个栈？

---
### 如何实现一个栈？

什么是栈（Stack）？
栈（stack）是一种采用后进先出（LIFO，last in first out）策略的抽象数据结构。比如物流装车，后装的货物先卸，先转的货物后卸。栈在数据结构中的地位很重要，在算法中的应用也很多，比如用于非递归的遍历二叉树，计算逆波兰表达式，等等。

栈一般用一个存储结构（常用数组，偶见链表），存储元素。并用一个指针记录栈顶位置。栈底位置则是指栈中元素数量为0时的栈顶位置，也即栈开始的位置。
栈的主要操作：

* push()，将新的元素压入栈顶，同时栈顶上升。
* pop()，将新的元素弹出栈顶，同时栈顶下降。
* empty()，栈是否为空。
* peek()，返回栈顶元素。

Python:
* 直接使用list，查看栈顶用[-1]这样的切片操作，弹出栈顶时用list.pop()，压栈时用list.append()。

如何自己实现一个栈？
参见问题：http://www.lintcode.com/en/problem/implement-stack/

栈在计算机内存当中的应用

我们在程序运行时，常说的内存中的堆栈，其实就是栈空间。这一段空间存放着程序运行时，产生的各种临时变量、函数调用，一旦这些内容失去其作用域，就会被自动销毁。
函数调用其实是栈的很好的例子，后调用的函数先结束，所以为了调用函数，所需要的内存结构，栈是再合适不过了。在内存当中，栈从高地址不断向低地址扩展，随着程序运行的层层深入，栈顶指针不断指向内存中更低的地址。

相关参考资料：
https://blog.csdn.net/liu_yude/article/details/45058687

---
### 如何用两个队列实现一个栈？

算法步骤

队列的知识请看：http://www.jiuzhang.com/tutorial/algorithm/391

两个队列实现一个栈，其实并没有什么优雅的办法。就看大家怎么去写这个东西了。

* 构造的时候，初始化两个队列，queue1，queue2。queue1主要用来存储，queue2则主要用来帮助queue1弹出元素以及访问栈顶。
* push：将元素推入queue1当中。
* pop：注意要弹出的元素在queue1末端，故将queue1中元素弹出，并直接推入queue2，当queue1只剩一个元素时，把它pop出来，并作为结果。而后交换两个队列。
* top：类似pop，不过不扔掉queue1中最后一个元素，而是把它也推入queue2当中。
* isEmpty：判断queue1是否为空即可。

相关题目
http://www.lintcode.com/zh-cn/problem/implement-stack-by-two-queues/

---
### 如何用一个数组实现三个栈？

题目描述

用一个数组实现三个栈。你可以假设这三个栈都一样大并且足够大。你不需要担心如果一个栈满了之后怎么办。
详见：http://www.lintcode.com/zh-cn/problem/implement-three-stacks-by-single-array/

算法描述

这道题的本质是把数组索引当作地址，用链表来实现栈。数组buffer中的每一个元素，并不能单单是简单的int类型，而是一个链表中的节点，它包含值value，栈中向栈底方向的之前元素索引prev，向栈顶方向的后来元素索引next。
在该三栈数据结构中，要记录三个栈顶指针stackPointer，也就是三个栈顶所在的数组索引，通过这三个栈顶节点，能够用prev找到整串栈。
此外还要用indexUsed记录整个数组中的所用的索引数。其实也就是下一次push的时候，向数组的indexUsed位置存储。

具体操作：

* 构造：要初始化stackPointer为3个-1,表示没有;indexUsed=0;buffer为一个长度为三倍栈大小的数组。
* push：要把新结点new在buffer[indexUsed]，同时修改该栈的stackPointer，indexUsed自增。注意修改当前栈顶结点prev和之前栈顶结点的next索引。
* peek：只需要返回buffer中对应的stackPointer即可。
* isEmpty：只需判断stackPointer是否为-1。
* pop：pop的操作较为复杂，因为有三个栈，所以栈顶不一定在数组尾端，pop掉栈顶之后，数组中可能存在空洞。而这个空洞又很难push入元素。所以，解决方法是，当要pop的元素不在数组尾端（即indexUsed-1）时，交换这两个元素。不过一定要注意，交换的时候，要注意修改这两个元素之前、之后结点的prev和next指针，使得链表仍然是正确的，事实上这就是结点中next的作用——为了找到之后结点并修改它的prev。在交换时，一种很特殊的情况是栈顶节点刚好是数组尾端元素的后继节点，这时需要做特殊处理。在交换完成后，就可以删掉数组尾端元素，并修改相应的stackPointer、indexUsed和新栈顶的next。

<br></br>
## 队列 Queue

队列通常被用作 BFS 算法的主要数据结构。除此之外面试中其他可能考察队列这个数据结构的地方并不多。我们这里把非 BFS 的队列考题考点做一个汇总：

1. 如何用链表实现队列？
2. 如何用两个栈实现一个队列？
3. 什么是循环数组，如何用循环数组实现队列？

---
### 如何用链表实现队列

定义

1. 队列为一种先进先出的线性表
2. 只允许在表的一端进行入队，在另一端进行出队操作。在队列中，允许插入的一端叫队尾，允许删除的一端叫队头，即入队只能从队尾入，出队只能从队头出

思路

1. 需要两个节点，一个头部节点，也就是dummy节点，它是在加入的第一个元素的前面，也就是dummy.next=第一个元素，这样做是为了方便我们删除元素，还有一个尾部节点，也就是tail节点，表示的是最后一个元素的节点
2. 初始时，tail节点跟dummy节点重合
3. 当我们要加入一个元素时，也就是从队尾中加入一个元素，只需要新建一个值为val的node节点，然后tail.next=node，再移动tail节点到tail.next
4. 当我们需要删除队头元素时，只需要将dummy.next变为dummy.next.next，这样就删掉了第一个元素，这里需要注意的是，如果删掉的是队列中唯一的一个元素，那么需要将tail重新与dummy节点重合
5. 当我们需要得到队头元素而不删除这个元素时，只需要获得dummy.next.val就可以了

---
### 如何用两个栈实现队列

我们已经知道，栈是一个先进后出的数据结构，而队列是一个先进先出的数据结构，那么如何用栈来实现队列呢？这里我们可以用两个栈来实现队列

思路:

现在我们已经有了两个栈stack1和stack2，最暴力的做法，当需要往队列中加入元素时，可以往其中一个栈stack2中加入元素，当需要得到队头元素时，只需要将stack2中的元素倒入到stack1中，再取stack1的头元素就可以了，如果是需要删掉队头元素，那么直接pop stack1的栈顶元素就可以了，再将stack1中的元素再倒入到stack2中，以便下一次的加入元素
上面的实现中，我们每取一次队头元素或者删掉队头元素，我们都需要将stack2中的元素先倒入到stack1中，再从stack1中倒回去，每次需要倒两边十分麻烦，那么是否有更加简便一些的方法呢？答案当然是有的，其实当我们将stack2中的元素倒入到stack1中的时候，我们发现stack1中的元素的顺序就是按照队列的先进先出顺序，那么我们不再将stack1中的元素倒入到stack2中，在获取队头元素或者删除队头元素的时候，我们先判断stack1是否为空，如果不为空，从stack1中取即可，如果为空，那么将stack2中的元素倒入到stack1中，每次加入元素的时候都是往stack2中加入元素。

---
### 什么是循环数组，如何用循环数组实现队列？

什么是循环数组
>Circular array = a data structure that used a array as if it were connected end-to-end

如何实现队列

1. 我们需要知道队列的入队操作是只在队尾进行的，相对的出队操作是只在队头进行的，所以需要两个变量front与rear分别来指向队头与队尾
2. 由于是循环队列，我们在增加元素时，如果此时 rear = array.length - 1 ，rear 需要更新为 0；同理，在元素出队时，如果 front = array.length - 1, front 需要更新为 0. 对此，我们可以通过对数组容量取模来更新。

在线练习
http://www.lintcode.com/zh-cn/problem/implement-queue-by-circular-array/#

<br></br>
## 哈希表 Hash

哈希表（Java 中的 HashSet / HashMap，C++ 中的 unordered_map，Python 中的 dict）是面试中非常常见的数据结构。它的主要考点有两个：

1. 是否会灵活的使用哈希表解决问题
2. 是否熟练掌握哈希表的基本原理

这一小节中，我们将介绍一下哈希表原理中的几个重要的知识点：

1. 哈希表的工作原理
2. 为什么 hash 上各种操作的时间复杂度不能单纯的认为是 O(1) 的
3. 哈希函数（Hash Function）该如何实现
4. 哈希冲突（Collision）该如何解决
5. 如何让哈希表可以不断扩容？

---
### 哈希表的基本原理
https://1256418761.vod2.myqcloud.com/c8e8a510vodtransgzp1256418761/d35375e17447398156689677704/v.f30.mp4

---
### 哈希函数 Hash Function
https://1256418761.vod2.myqcloud.com/c8e8a510vodtransgzp1256418761/7c96cd2c7447398156688215012/v.f30.mp4

---
### 冲突的解决办法

冲突（Collision），是说两个不同的 key 经过哈希函数的计算后，得到了两个相同的值。解决冲突的方法，主要有两种：

1. 开散列法（Open Hashing）。是指哈希表所基于的数组中，每个位置是一个 Linked List 的头结点。这样冲突的 <key, value> 二元组，就都放在同一个链表中。
2. 闭散列法（Closed Hashing）。是指在发生冲突的时候，后来的元素，往下一个位置去找空位。

#### 开哈希 Open Hashing
https://1256418761.vod2.myqcloud.com/c8e8a510vodtransgzp1256418761/81c21a257447398156688489780/v.f30.mp4

#### 闭哈希 Closed Hashing
https://1256418761.vod2.myqcloud.com/c8e8a510vodtransgzp1256418761/783352957447398156688052634/v.f30.mp4

---
### 重哈希 Rehashing
https://1256418761.vod2.myqcloud.com/c8e8a510vodtransgzp1256418761/c5096bbf7447398156689032987/v.f30.mp4

<br></br>
## 堆 Heap

---
### Heap 的结构和原理
https://1256418761.vod2.myqcloud.com/c8e8a510vodtransgzp1256418761/79c6c5e07447398156759285737/v.f40.mp4

---
### 堆化 Heapify
基于 Siftup 的版本 O(nlogn)

算法思路：

1. 对于每个元素A[i]，比较A[i]和它的父亲结点的大小，如果小于父亲结点，则与父亲结点交换。
2. 交换后再和新的父亲比较，重复上述操作，直至该点的值大于父亲。

时间复杂度分析

1. 对于每个元素都要遍历一遍，这部分是 O(n)。
2. 每处理一个元素时，最多需要向根部方向交换 logn 次。

因此总的时间复杂度是 O(nlogn)

基于 Siftdown 的版本 O(n)

算法思路：

1. 初始选择最接近叶子的一个父结点，与其两个儿子中较小的一个比较，若大于儿子，则与儿子交换。
2. 交换后再与新的儿子比较并交换，直至没有儿子。
3. 再选择较浅深度的父亲结点，重复上述步骤。

时间复杂度分析

这个版本的算法，乍一看也是 O(nlogn)， 但是我们仔细分析一下，算法从第 n/2 个数开始，倒过来进行 siftdown。也就是说，相当于从 heap 的倒数第二层开始进行 siftdown 操作，倒数第二层的节点大约有 n/4 个， 这 n/4 个数，最多 siftdown 1次就到底了，所以这一层的时间复杂度耗费是 O(n/4)，然后倒数第三层差不多 n/8 个点，最多 siftdown 2次就到底了。所以这里的耗费是 O(n/8 * 2), 倒数第4层是 O(n/16 * 3)，倒数第5层是 O(n/32 * 4) ... 因此累加所有的时间复杂度耗费为：

T(n) = O(n/4) + O(n/8 * 2) + O(n/16 * 3) ...

因此得到 T(n) = 2 * T(n) - T(n) = O(n)


<br></br>
## 课后补充内容

---
### 红黑树 Red-black Tree

红黑树（Red-black Tree）是一种平衡排序二叉树（Balanced Binary Search Tree），在它上面进行增删查改的平均时间复杂度都是 O(logn)O(logn)，是居家旅行的常备数据结构。

Q: 在面试中考不考呢？
A: 很少考……

Q: 需不需要了解呢？
A: 需要！

Q: 了解到什么程度呢？
A: 知道它是 Balanced Binary Search Tree，知道它支持什么样的操作，会用就行。不需要知道具体的实现原理。

在Python当中，默认的set和dict是用哈系表实现，没有默认的红黑树。如果你想使用红黑树的话，可以使用rbtree这个模块，下载地址：https://pypi.python.org/pypi/rbtree/0.9.0

---
### Merge K Sorted Lists 多路归并算法的三种实现方式
https://1256418761.vod2.myqcloud.com/c8e8a510vodtransgzp1256418761/029813f37447398156761444680/v.f40.mp4

---
### 外排序与K路归并算法

__介绍__

外排序算法（External Sorting），是指在内存不够的情况下，如何对存储在一个或者多个大文件中的数据进行排序的算法。外排序算法通常是解决一些大数据处理问题的第一个步骤，或者是面试官所会考察的算法基本功。外排序算法是海量数据处理算法中十分重要的一块。
在学习这类大数据算法时，经常要考虑到内存、缓存、准确度等因素，这和我们之前见到的算法都略有差别。

__基本步骤__

外排序算法分为两个基本步骤：

1. 将大文件切分为若干个个小文件，并分别使用内存排好序
2. 使用K路归并算法（k-way merge）将若干个排好序的小文件合并到一个大文件中

第一步：文件拆分

根据内存的大小，尽可能多的分批次的将数据 Load 到内存中，并使用系统自带的内存排序函数（或者自己写个快速排序算法），将其排好序，并输出到一个个小文件中。比如一个文件有1T，内存有1G，那么我们就这个大文件中的内容按照 1G 的大小，分批次的导入内存，排序之后输出得到 1024 个 1G 的小文件。

第二步：K路归并算法

K路归并算法使用的是数据结构堆（Heap）来完成的，使用 Java 或者 C++ 的同学可以直接用语言自带的 PriorityQueue（C++中叫priority_queue）来代替。

我们将 K 个文件中的第一个元素加入到堆里，假设数据是从小到大排序的话，那么这个堆是一个最小堆（Min Heap）。每次从堆中选出最小的元素，输出到目标结果文件中，然后如果这个元素来自第 x 个文件，则从第 x 个文件中继续读入一个新的数进来放到堆里，并重复上述操作，直到所有元素都被输出到目标结果文件中。

Follow up: 一个个从文件中读入数据，一个个输出到目标文件中操作很慢，如何优化？

如果我们每个文件只读入1个元素并放入堆里的话，总共只用到了 1024 个元素，这很小，没有充分的利用好内存。另外，单个读入和单个输出的方式也不是磁盘的高效使用方式。因此我们可以为输入和输出都分别加入一个缓冲（Buffer）。假如一个元素有10个字节大小的话，1024 个元素一共 10K，1G的内存可以支持约 100K 组这样的数据，那么我们就为每个文件设置一个 100K 大小的 Buffer，每次需要从某个文件中读数据，都将这个 Buffer 装满。当然 Buffer 中的数据都用完的时候，再批量的从文件中读入。输出同理，设置一个 Buffer 来避免单个输出带来的效率缓慢。

Lintcode相关练习

[合并K个有序数组](http://www.lintcode.com/zh-cn/problem/merge-k-sorted-arrays/)

[合并K个有序链表](http://www.lintcode.com/zh-cn/problem/merge-k-sorted-lists/)

面试相关问题

[面试题：合并 K 个排好序的大文件](http://www.jiuzhang.com/tutorial/big-data-interview-questions/221)

[面试题：求两个超大文件中 URLs 的交集](http://www.jiuzhang.com/tutorial/big-data-interview-questions/269)

更多海量数据算法相关知识可参见

[九章算法——海量数据处理算法与面试题全集](http://www.jiuzhang.com/tutorial/big-data-interview-questions/148)

